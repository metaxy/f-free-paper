\documentclass[12pt,a4paper,onecolumn,oneside,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

%for pseudocode
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{caption}

\DeclareCaptionFormat{algor}{%
  \hrulefill\par\offinterlineskip\vskip1pt%
    \textbf{#1#2}#3\offinterlineskip\hrulefill}
\DeclareCaptionStyle{algori}{singlelinecheck=off,format=algor,labelsep=space}
\captionsetup[algorithm]{style=algori}

%return on a new line
\let\oldReturn\Return
\renewcommand{\Return}{\State\oldReturn}

\newcommand{\vars}{\texttt}
\newcommand{\func}{\textsc}


\newcommand\todo[1]{\textcolor{red}{#1}}
%\renewcommand\todo[1]{}

\usepackage[usenames,dvipsnames,svgnames,table]{xcolor} % for coloring text
\author{Paul Walger}
\title{Heuristiken für das Entfernen von verbotenen Teilgraphen}
\makeindex
\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Abstract}

\section{Einleitung}


\subsection{Motivation}


\subsection{Anwendungsbeispiele}

\subsubsection{Soziale Netzwerke}
$(P_4,C_4)$-freie Graphen modellieren eine soziale Struktur.\cite{NastosG13}

Ähnlich dazu sind $(P_5,C_5)$-freie Graphen die auch soziale Strukturen modellieren und afür geeignet sind Gemeinschaften zu identifizieren. \cite{Schoch15}

\subsubsection{Protein interaction networks}
$(2K_2, C_4, C_5)$-freie Graphen haben gewisse Vorteile für die Untersuchung von Interaktionsnetzwerken von Proteinen \cite{BrucknerHK15}.

\subsection{Definitionen}
\subsubsection{Notationen und Definitionen}
Mit Graphen sei im Folgenden stets ein ungerichteter, einfacher Graph gemeint. Wenn nicht anders angegeben ist $G=(V,E)$ ein Graph, $V$ die Menge seiner Knoten und E die Menge seiner Kanten.

Sei $G = (V,E)$ ein Graph und $S \subseteq V$ eine beliebige Knotenmenge von $V$. 
Dann ist $G[S]$ der auf $S$ induzierte Subgraph von $G$ mit $G[S] = (S, E \cap \{\{u,v\} \,|\, u \in S \land w \in S\})$

$N(u)$ ist die Nachbarschaft vom Knoten $u$. $N^{*}(u)$ ist die Nachbarschaft von $u$ mit $u$ inklusive.

Sei $H = (V_H,E_H)$ und $G =(V,E)$ zwei Graphen. Ein Subgraph-Isomorphismus von H nach G ist eine Funktion $f : V_H \rightarrow V$ sodass wenn $(u,v) \in E_H $, dann auch $(f(u),f(v)) \in E$. $f$ ist ein induzierter Subgraph-Isomorphismus, wenn es auch gilt, dass wenn $(u,v) \notin E_H$, dann auch $(f(u),f(v)) \notin E$.

\subsubsection{Problemstellung}


\subsection{Ähnliche Arbeiten}
Implicit Hitting Set hilft hier leider nicht viel.\cite{Moreno13} 

Approximation von H-Free Editing für montone graphen eigenschaften: $o(n^2)$ ist effizient, aber $O(n^{2-\epsilon})$ ist NP-Hard.\cite{Alon09}




\section{Algorithmen}
Die nachfolgenden beschriebenen Algorithmen basieren alle auf dem folgenden Prinzip: Suche einen validen Graphen, welcher die verbotenen Subgraphen nicht enthält. Dann gebe, die Differenz zwischen dem erstellen validen Graphen und dem Eingabegraphen. Dies wird in dem Algorithmus \ref{algo:general} noch einmal beschrieben. Dabei steht \func{SolveAlgo} für einen der Algorithmen, die wir in den folgenden Abschnitten betrachten werden.
\begin{algorithm}
  \captionof{algorithm}{Genereller Aufbau}\label{algo:general}
\begin{algorithmic}[1]
\Function{Solve}{\vars{graph}, \vars{forbidden}, \vars{iterations}}

\State{\vars{bestGraph} $\gets$ $(\emptyset,\emptyset)$}

\For{\vars{i} = 1 to \vars{iterations}}
	\State{\vars{validGraph} $\gets$ \func{solveAlgo}(\vars{graph}, \vars{forbidden})}
	\If{\func{diff}(\vars{bestGraph}, \vars{graph}) < \func{diff}(\vars{validGraph}, \vars{graph})}
		\State{\vars{bestGraph} $\gets$ \vars{validGraph}}
	\EndIf  
\EndFor

\State{print \func{diff}(\vars{graph}, \vars{bestGraph})}
\EndFunction
\end{algorithmic}
\end{algorithm}

Da alle Ansätze diesen Schritte enthalten und sich nur in dem unterschieden, wie der valide Graph gefunden wird, wird folgend nur dieser Aspekt betrachtet.

Die entwickelten Ansätze sind in 3 große Gruppen zu unterteilen.
Der Top-Bottom-Ansatz nimmt den Graphen und ändert ihn solange, bis ein gültiger Graph entsteht. Der Bottom-Top-Ansatz fängt mit einem leeren oder vollen Graphen an, und ändert solange Konten, bis man möglichst nahe an dem Eingabegraphen ist.
Der Grow-Reduce-Ansatz kombiniert diese beiden Ansätze, indem es unterschiedliche Stadien gibt… 

\subsection{Top-Bottom}
Der Top-Bottom-Ansatz nimmt den Graphen und ändert ihn solange, bis ein gültiger Graph entsteht.

\subsubsection{RandomChange}
Das ist der einfachste Algorithmus. 
\begin{algorithm}
  \captionof{algorithm}{RandomChange}\label{algo:RandomChange}
\begin{algorithmic}[1]
\Function{RandomChangeSolve}{\vars{graph}, \vars{forbidden}}
\For{Graph \vars{f} $\in$ \vars{forbidden} }
	\State{\vars{forbiddenSubgraph} $\gets$ \func{findFS}(\vars{graph}, \vars{f})}
	\While{forbiddenSubgraph  $\neq \emptyset$}
		\State{change a random edge $\in$ \vars{forbiddenSubgraph}}
		\State{\vars{forbiddenSubgraph} $\gets$	 \func{findFS}(\vars{graph}, \vars{f})}
	\EndWhile
\EndFor
\Return{\vars{graph}}
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Random}
Es ist wie RandomChange\footnote{Algorithmus \ref{algo:RandomChange}}, aber bereits editierte Kanten werden mit einer geringeren Wahrscheinlichkeit geändert.
Auch hat es für kleine Graphen ein Konvergenzkriterium. Dieses Konvergenzkriterum besteht darin, dass nach für jede Änderung, die Anzahl der verbotenen Subgraphen gezählt wird und die nur dann ausgeführt wird, wenn die Anzahl der verbotenen Subgraphen dadurch weniger wird.

\begin{algorithm}
  \captionof{algorithm}{Random}\label{algo:Random}
\begin{algorithmic}[1]
\Function{StateRandom2Solve}{\vars{graph}, \vars{forbidden}}
\For{Graph \vars{f} $\in$ \vars{forbidden} }
	\State{f\vars{forbiddenSubgraph} $\gets$ \func{findFS}(\vars{graph}, \vars{f})}
	\While{\vars{forbiddenSubgraph} != $\emptyset$}
	    \State{\vars{foundEdge} $\gets \emptyset$}
		\While{true}
			\State{\vars{e} $\gets$ random edge from \vars{forbiddenSubgraph}}
			\State{\vars{prob} $\gets$ 1 / \#(E(f))}
			\If{e is already visited}
				\State{\vars{prob} $\gets$ \vars{prob} / 4}
		    \EndIf
		    \If{random number from [0,1] > prob}
		    	\State{\vars{foundEdge} $\gets$ \vars{e}}
		    	\State{break}
		    \EndIf
		    \State{flip \vars{e} in \vars{graph}}
		\EndWhile
		\State{\vars{forbiddenSubgraph} $\gets$ \func{findFS}(\vars{graph}, \vars{f})}
	\EndWhile
\EndFor
\Return{\vars{graph}}
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Bottom-Top}

\subsubsection{Extend}
\begin{algorithm}
  \captionof{algorithm}{F-Free Extend}\label{euclid}
\begin{algorithmic}[1]
\Function{StateExtendSolve}{\vars{input}, \vars{forbidden}}
	\State{\vars{graph} = $(\emptyset,\emptyset)$}
	\While{true}
		\For{each Edge \vars{e} $\in$ \func{Difference}(\vars{graph},\vars{input}) }
			\State{try to flip \vars{e}, revert if it produces an invalid graph}
		\EndFor
		\State{break if there was no change}
	\EndWhile
\Return{\vars{graph}}
\EndFunction
\end{algorithmic}
\end{algorithm}


\subsection{Grow-Reduce}
Der Grow-Reduce-Ansatz ist ein Art von einer greedy randomized adaptive search procedure(GRASP).\todo{GRASPH beschreiben Siehe \cite{Bastos2014}}
Der Grow-Reduce-Ansatz sieht wie folgt aus: Begonnen wird mit einem leeren Graphen, dann wird in jeder Iteration ein Knoten und seine Umgebung hinzugefügt und durch lokale Suche werden alle neu entstandenen verbotenen Subgraphen wieder entfernt.

\begin{algorithm}
  \captionof{algorithm}{GrowReduce}\label{algo:GrowReduce}
\begin{algorithmic}[1]
\Function{GrowReduceSolve}{\vars{input}, \vars{forbidden}}
	\State{\vars{graph} $\gets$ $(\emptyset,\emptyset)$}
	\State{\vars{nodes} $\gets$ \func{randomOrder}(V(\vars{input}))}
	\For{\vars{node} $\in$ \vars{nodes}}
		
		\For{\vars{neighbor} $\in$ N(\vars{node})}\Comment{Grow Phase}
			\State{Add Edge (\vars{node}, \vars{neighbor}) to \vars{graph}}
		\EndFor
		
	\EndFor
\Return{\vars{graph}}
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{FPT}
\subsection{Lineare Programmierung}
\subsubsection{Lineare Optimierung}
Bei der linearen Optimierung wird eine lineare Zielfunktion minimiert bzw. maximiert, wobei sie durch lineare Gleichungen und Ungleichungen beschränkt ist.
\subsubsection{Das Model des Graphen}
Wir nutzen binäre Variablen $e_{uv}$, wobei $u,v \in V$ sind und $u < v$ gilt.
Dabei ist $e_{uv} = 1$ genau dann wenn, die kante ${u,v}$ ein Teil des Lösungsgraphen ist.

Wir minimieren \[\sum_{u,v \in V} 
\begin{cases} 
      e_{u,v} & \{u,v\} \in E \\
      -e_{u,v} & \{u,v\} \notin E
   \end{cases}\].
   
Da alle möglichen Bedingungen hinzuzufügen, welche bei alle verbotenen Subgraphen ausschließen wpürden, viel zum umfangreich wäre, werden die Bedingungen iterative dort hinzu gefügt, wo es einen verbotenen Teilgraphen gibt. Dann wird der Problem gelöst und und die Änderungen auf den Graphen übertragen. Dann wird wieder nach alle verboteten Subgraphen gesucht. Dies wird solange wiederholt bis es keine mehr gibt. Nun ist die minimale Anzahl von Änderungen gefunden. 

\begin{algorithm}
  \captionof{algorithm}{F-Free BLP}\label{euclid}
\begin{algorithmic}[1]
\Function{solveBLP}{\vars{graph}, \vars{algo:blp}}
\For{graph \vars{f} $\in$ \vars{forbidden}}
	\While{\func{findFS}(graph, f) != $\emptyset$}
		\For{each graph M $\in$ \func{findeVerboteneSubgraphen}(\vars{graph}, \vars{f}) }
			\State{contstraint = 0}
			\For{each $\{u,v\}$ $\in$ kanten(M)}
				\If{$\{u,v\}$ $\in$ kanten(graph)} 
					\State{contstraint += 1 - $e_{uv}$} 
				\Else 
					\State{contstraint += $e_{uv}$} 
				\EndIf
			\EndFor
			\State{addConstraint(contstraint)}
		\EndFor
		\State{graph = lpSolve(graph)}
	\EndWhile
\EndFor
\Return(graph)
\EndFunction
\end{algorithmic}
\end{algorithm}




\subsection{Relaxierte Lineare Programmierung}


\section{Aufbau der Test}
\subsection{Datensätze}
Folgende Datensätze wurden verwendet.
\subsubsection{albert barabasi}
Für den Datensatz albert barabasi wurde das Barabasi–Albert Modell, welches ein zufälliges skalenfreies Netz erzeugt.\cite{Albert02}

Anzahl: 56

\subsubsection{newman watts strogatz}
Anzahl: 144
\subsubsection{UCINetworkDataRepository}
Anzahl: 9
\subsubsection{bio1}
Anzahl: 147
\todo{Was ist die Quelle für diese Daten}
\subsubsection{bio2}
Anzahl: 360
\todo{Was ist die Quelle für diese Daten}

\subsection{Optimale Lösung}
Um die Qualität der Lösung eines heuristischen Ansatzes bewerten zu können, ist es sehr gut die optimale Lösung zu wissen. Es gibt verschiedene Ansatz wie das Problem zu lösen sein, wir haben uns jedoch für die lineare Optimierung entschieden.

\section{Implementation}
\subsection{Repräsentation vom Graphen}
Die Graphen werden in einer Adjazenzmatrix gespeichert.


\subsection{Das Finden von induzierten Subgraphen}
\cite{Ullmann76}
Wie verwenden einen VF Algorithmus für \func{findFS}(\vars{graph},\vars{forbidden}).
Dieser gibt gibt eine Menge von Subgraphen zurück.

\subsubsection{Vergleich VFLib, Boost und eigne Implemtation}
\begin{tabular}{|c|c|c|c|}
\hline 
• & find all p3s & count all p3s & has a p3 \\ 
\hline 
Spezial & 0.73s & 0.04s & 0.00016s \\ 
\hline 
VFLib & 1.73s & 0.87s & 0.01236s \\ 
\hline 
Boost & 3.04s & 1.68 & 0.00102s \\ 
\hline 
\end{tabular} 
\\

Bei VFLib ist der Graph immutable und bei der Suche nach einem  Subgraphen müssen wir jedes Mal den Graphen neu erstellen.


\section{Auswertung}

\section{Vergleich mit anderen Heuristiken}
\subsection{Cluster-Editing}
\subsubsection{2K-Heuristik}
Die 2K-Heuristik, basiert auf einem Kernel für das Cluster-Editing-Problem, welches maximal 2K Knoten liefert \cite{Chen12}. Wenn man dort eine Bedingung für die \todo{?.} Reduktionsregel abschwächt  abschwächt, kommt eine sehr gute Heuristik für das Cluster-Editing-Problem heraus. Dabei wird die Bedingung mit jedem Durchlauf abgeschwächt.
\pagebreak
\begin{center}
  \captionof{algorithm}{2K Heuristik}\label{euclid}
\begin{algorithmic}[1]
\Function{solve2K}{g :: Gewichteter Graph}
\State{a = 1,0} 
\While{graph hat einen P3}
	\For{each knoten u $\in$ g}
		\If{$2 \cdot a \cdot costClique(g, u) + a \cdot costCut(g, u) < \#(N(u))$}
			\For{each $\{a,b\}$  mit $a \in N(u)$, $b \in N(u) \land a \neq b$}
				\State{merge(a,b)}
			\EndFor
		\EndIf
	\EndFor
	\State{$a = 0,99 \cdot a - 0,01$}
\EndWhile

\Return{graph}
\EndFunction

\Function{costClique}{graph :: Gewichteter Graph, u :: Kante}
\State{cost = 0}
	\For{each $\{a,b\}$  mit $a \in N^{*}(u)$, $b \in N^{*}(u) \land \{a,b\} \notin graph$}
		\State{cost += $|\,w(\{a,b\})\,|$}
	\EndFor

\Return{cost}
\EndFunction
\Function{costCut}{graph :: Gewichteter Graph, u :: Kante}
\State{cost = 0}
	\For{each $\{a,b\}$  mit $a \in N^{*}(u)$, $b \notin N^{*}(u) \land \{a,b\} \in graph$}
		\State{cost += $w(\{a,b\})$}
	\EndFor

\Return{cost}
\EndFunction
\end{algorithmic}
\end{center}


\subsubsection{Andere Heuristiken}
\cite{Bastos2014} Effiziente Algorithmen

 \todo{GRASP Heuritik}
 \todo{ILS Heuristik}

\subsection{Quasi-Threshold Mover}
In \cite{BrandesHSW15} wurde ein neuer schneller und auch für große Graphen geeigneter Algorithmus entwickelt für das Quasi-Threshold Editing Problem. Quasi-Threshold Graphen, auch bekannt als trivial perfekte Graphen lassen sich auch als $(P_4, C_4)$ - freie Graphen charakterisieren. 


Vergleich mit mit meinem Algorithmus.


\section{Zukünftige Forschungsmöglichkeiten}
\section{Zusammenfassung}

\bibliographystyle{plain}
\bibliographystyle{te}
\bibliography{biblio}

\end{document}
